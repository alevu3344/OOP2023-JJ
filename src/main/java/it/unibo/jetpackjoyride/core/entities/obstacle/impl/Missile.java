package it.unibo.jetpackjoyride.core.entities.obstacle.impl;

import it.unibo.jetpackjoyride.core.entities.entity.api.Entity;
import it.unibo.jetpackjoyride.core.entities.obstacle.api.AbstractObstacle;
import it.unibo.jetpackjoyride.core.entities.obstacle.api.Obstacle;
import it.unibo.jetpackjoyride.core.hitbox.api.Hitbox;
import it.unibo.jetpackjoyride.core.movement.Movement;
import it.unibo.jetpackjoyride.utilities.GameInfo;
import it.unibo.jetpackjoyride.utilities.MovementChangers;
import java.util.List;

/**
 * The {@link Missile} class defines one of the obstacles implemented
 * in the game. Since it extends {@link AbstractObstacle}, it inherits all
 * methods and behaviours of {@link Entity} and {@link Obstacle}.
 * Missile are really fast and can easily hit an unprepared player, but to
 * compensate that, they are small entities and warn the player about where
 * from they will launch.
 * 
 * @author gabriel.stira@studio.unibo.it
 */
public final class Missile extends AbstractObstacle {
    /**
     * Defines the X coordinate at which the missile status will be set to INACTIVE.
     */
    private static final Double OUT_OF_BOUNDS_SX = -100.0;
    /**
     * Defines the duration of the explosion of the missile.
     */
    private static final Integer DELAY_BEFORE_DESTRUCTION = 50;
    /**
     * Defines how long the warning will be shown to the player.
     */
    private static final Integer DELAY_BEFORE_ACTIVATING = 150;
    /**
     * Defines the X coordinate of the warning.
     */
    private static final Double WARNING_SPAWNING_X = 1220.0;
    /**
     * Defines the X coordinate the missile is generated by default.
     */
    private static final Double OUT_OF_BOUNDS_DX = 1350.0;

    /**
     * Defines a counter used to handle the missile deactivation phase.
     */
    private Integer lifetimeAfterDeactivation;

    /**
     * Movement characteristics of the entity when spawned (needed for entities
     * which need to know what
     * their movement was initially).
     */
    private final Movement movementBuffer;

    /**
     * Constructor used to create an instance of the class Missile.
     * 
     * @param newMovement The movement characteristics of the missile obstacle.
     * @param hitbox      The collision characteristics of the missile obstacle.
     */
    public Missile(final Movement newMovement, final Hitbox hitbox) {
        super(ObstacleType.MISSILE, newMovement, hitbox);
        this.lifetimeAfterDeactivation = DELAY_BEFORE_DESTRUCTION + DELAY_BEFORE_ACTIVATING; // Counter initialized
        this.setEntityStatus(EntityStatus.CHARGING); // Missiles spawn with a CHARGING status

        final Double startingXSpeed = Double.valueOf(GameInfo.MOVE_SPEED.get());
        this.movementBuffer = new Movement.Builder()
                .setPosition(this.getEntityMovement().getPosition())
                .setSpeed(-startingXSpeed * 2, this.getEntityMovement().getSpeed().get2())
                .setAcceleration(this.getEntityMovement().getAcceleration())
                .setRotation(this.getEntityMovement().getRotation())
                .setMovementChangers(
                    this.getEntityMovement().getSpeed().get2() != 0 ? 
                                    List.of(MovementChangers.BOUNCING) : List.of())
                .build();
    }

    /**
     * Updates the status of the missile entity based on its lifetime and position.
     * 
     * @param isSpaceBarPressed Is ignored by this entity.
     */
    @Override
    protected void updateStatus(final boolean isSpaceBarPressed) {
        if (this.getEntityStatus().equals(EntityStatus.CHARGING)) {
            /*
             * Since at the beginning the missile has to be shown as a warning,
             * a buffer for the correct movement is used and its movement is initially set
             * to a static one
             */
            if (this.getLifetime().equals(1)) {
                this.setEntityMovement(new Movement.Builder()
                        .setPosition(WARNING_SPAWNING_X, this.getEntityMovement().getPosition().get2())
                        .setRotation(this.getEntityMovement().getRotation())
                        .build());
            }

            this.lifetimeAfterDeactivation--;
            if (this.lifetimeAfterDeactivation.equals(DELAY_BEFORE_DESTRUCTION)) {
                this.setEntityStatus(EntityStatus.ACTIVE);

                this.setEntityMovement(new Movement.Builder()
                        .setPosition(OUT_OF_BOUNDS_DX, this.movementBuffer.getPosition().get2())
                        .setSpeed(this.movementBuffer.getSpeed())
                        .setAcceleration(this.movementBuffer.getAcceleration())
                        .setRotation(this.movementBuffer.getRotation())
                        .setMovementChangers(this.movementBuffer.getMovementChangers())
                        .build());
            }
        }

        /*
         * Only if specific conditions are met the missile status will be set to
         * INACTIVE
         */
        if (this.getEntityStatus().equals(EntityStatus.DEACTIVATED)
                && this.lifetimeAfterDeactivation > DELAY_BEFORE_DESTRUCTION
                || this.getEntityMovement().getPosition().get1() < OUT_OF_BOUNDS_SX
                || this.lifetimeAfterDeactivation < 0) {
            this.setEntityStatus(EntityStatus.INACTIVE);
        }

        if (this.getEntityStatus().equals(EntityStatus.DEACTIVATED)) {
            if (this.lifetimeAfterDeactivation.equals(DELAY_BEFORE_DESTRUCTION)) {
                this.setEntityMovement(new Movement.Builder()
                        .setPosition(this.getEntityMovement().getPosition())
                        .setSpeed(this.getEntityMovement().getSpeed().get1(), 0.0)
                        .build());
            }
            this.lifetimeAfterDeactivation--;
        }
    }
}
