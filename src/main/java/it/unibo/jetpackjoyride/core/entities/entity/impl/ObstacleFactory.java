package it.unibo.jetpackjoyride.core.entities.entity.impl;

import it.unibo.jetpackjoyride.core.entities.obstacle.api.Obstacle;
import it.unibo.jetpackjoyride.core.entities.obstacle.api.Obstacle.ObstacleType;
import it.unibo.jetpackjoyride.core.entities.obstacle.impl.Laser;
import it.unibo.jetpackjoyride.core.entities.obstacle.impl.Missile;
import it.unibo.jetpackjoyride.core.entities.obstacle.impl.Zapper;
import it.unibo.jetpackjoyride.core.hitbox.api.Hitbox;
import it.unibo.jetpackjoyride.core.hitbox.impl.HitboxImpl;
import it.unibo.jetpackjoyride.core.movement.Movement;
import it.unibo.jetpackjoyride.utilities.Pair;
import it.unibo.jetpackjoyride.utilities.exceptions.NotImplementedObjectException;

/**
 * The {@link ObstacleFactory} class is a factory for all {@link Obstacle}.
 * {@link Obstacle} have to be generated by supplying an {@link ObstacleType} and a {@link Movement}.
 * The entity is generated by combining the two classes {@link HitboxImpl} and {@link Movement}.
 * The {@link Hitbox} class is fixed for every type of entity and doesn't need to
 * be provided.
 * 
 * @author gabriel.stira@studio.unibo.it
 */
public class ObstacleFactory {
    /*
     * Define the dimensions of the hitbox of the obstacles.
     */
    private static final Pair<Double, Double> MISSILE_HITBOX_DIMENSIONS = new Pair<>(40.0, 15.0);
    private static final Pair<Double, Double> ZAPPER_HITBOX_DIMENSIONS = new Pair<>(160.0, 30.0);
    private static final Pair<Double, Double> LASER_HITBOX_DIMENSIONS = new Pair<>(980.0, 24.0);

    /**
     * Generates an {@link Obstacle} based on the supplied {@link ObstacleType} and {@link Movement}.
     * @param obstacleType The type of the obstacle to generate.
     * @param obstacleMovement The movement of the obstacle to generate.
     * @return An {@link Obstacle} with the specified {@link ObstacleType} and {@link Movement}.
     */
    public Obstacle generateObstacle(final ObstacleType obstacleType, final Movement obstacleMovement) {
        Hitbox obstacleHitbox;
        Obstacle obstacleModel;
        final Movement newMovement = new Movement.Builder()
                .addNewPosition(obstacleMovement.getPosition())
                .addNewSpeed(obstacleMovement.getSpeed())
                .addNewAcceleration(obstacleMovement.getAcceleration())
                .addNewRotation(obstacleMovement.getRotation())
                .addNewMovementChangers(obstacleMovement.getMovementChangers())
                .build();
        try {
            switch (obstacleType) {
                case MISSILE: // Canon obstacle existing in the original game
                    obstacleHitbox = new HitboxImpl(newMovement.getPosition(), MISSILE_HITBOX_DIMENSIONS,
                            newMovement.getRotation().get1());
                    obstacleModel = new Missile(newMovement, obstacleHitbox);
                    break;
                case ZAPPER: // Canon obstacle existing in the original game
                    obstacleHitbox = new HitboxImpl(newMovement.getPosition(), ZAPPER_HITBOX_DIMENSIONS,
                            newMovement.getRotation().get1());
                    obstacleModel = new Zapper(newMovement, obstacleHitbox);
                    break;
                case LASER: // Canon obstacle existing in the original game
                    obstacleHitbox = new HitboxImpl(newMovement.getPosition(), LASER_HITBOX_DIMENSIONS,
                            newMovement.getRotation().get1());
                    obstacleModel = new Laser(newMovement, obstacleHitbox);
                    break;
                default:
                    throw new NotImplementedObjectException(
                            "EntityModelGenerator could not generate the obstacle. A missile will be generated instead.");
            }
        } catch (NotImplementedObjectException e) {
            obstacleHitbox = new HitboxImpl(newMovement.getPosition(), MISSILE_HITBOX_DIMENSIONS, 0.0);
            obstacleModel = new Missile(newMovement, obstacleHitbox);
        }

        return obstacleModel;
    }
}
